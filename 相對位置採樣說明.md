# 基於相對位置採樣的詳細說明

## 1. 傳統方法 vs 相對位置方法

### 傳統方法（錯誤的）：
```
假設要採樣5個點：

左影像蝦子範圍：x ∈ [700, 900]
採樣點：x = 700, 750, 800, 850, 900

右影像蝦子範圍：x ∈ [650, 850]  
採樣點：x = 650, 700, 750, 800, 850

問題：x=700在左影像是頭部，在右影像是身體中段！
```

### 相對位置方法（正確的）：
```
使用相對位置參數 t ∈ [0, 1]：

t = 0.0  → 蝦子頭部
t = 0.25 → 蝦子前1/4處  
t = 0.5  → 蝦子身體中段
t = 0.75 → 蝦子後1/4處
t = 1.0  → 蝦子尾部

左影像：
t=0.0  → x = 700 + 0.0 × (900-700) = 700 (頭部)
t=0.25 → x = 700 + 0.25 × (900-700) = 750 (前1/4)
t=0.5  → x = 700 + 0.5 × (900-700) = 800 (中段)
t=0.75 → x = 700 + 0.75 × (900-700) = 850 (後1/4)  
t=1.0  → x = 700 + 1.0 × (900-700) = 900 (尾部)

右影像：
t=0.0  → x = 650 + 0.0 × (850-650) = 650 (頭部)
t=0.25 → x = 650 + 0.25 × (850-650) = 700 (前1/4)
t=0.5  → x = 650 + 0.5 × (850-650) = 750 (中段)
t=0.75 → x = 650 + 0.75 × (850-650) = 800 (後1/4)
t=1.0  → x = 650 + 1.0 × (850-650) = 850 (尾部)
```

## 2. 程式碼實作詳解

### 步驟1：取得蝦子範圍
```python
# 從遮罩中取得蝦子的實際像素範圍
left_x_coords, left_y_coords = np.where(left_mask > 0)
right_x_coords, right_y_coords = np.where(right_mask > 0)

# 計算蝦子的x座標範圍
left_x_min, left_x_max = left_x_coords.min(), left_x_coords.max()
right_x_min, right_x_max = right_x_coords.min(), right_x_coords.max()
```

### 步驟2：產生相對位置參數
```python
# 產生n_points個均勻分布的相對位置
t_values = np.linspace(0, 1, n_points)
# 例如：n_points=5 → t_values = [0.0, 0.25, 0.5, 0.75, 1.0]
```

### 步驟3：映射到實際座標
```python
# 將相對位置映射到左影像的實際x座標
left_x = left_x_min + t_values * (left_x_max - left_x_min)

# 將相同的相對位置映射到右影像的實際x座標
right_x = right_x_min + t_values * (right_x_max - right_x_min)
```

### 步驟4：計算對應的y座標
```python
# 使用擬合的曲線方程計算y座標
# 以二次曲線為例：y = ax² + bx + c

# 左影像的y座標
left_y = a_left * left_x**2 + b_left * left_x + c_left

# 右影像的y座標  
right_y = a_right * right_x**2 + b_right * right_x + c_right
```

## 3. 視覺化說明

```
蝦子示意圖（俯視）：

左影像：                右影像：
   頭部    身體    尾部      頭部    身體    尾部
    ●─────●─────●          ●─────●─────●
   700   800   900        650   750   850
    ↑     ↑     ↑          ↑     ↑     ↑
   t=0   t=0.5  t=1       t=0   t=0.5  t=1

對應關係：
t=0   : (700, y1) ←→ (650, y1')  [頭部對頭部]
t=0.5 : (800, y2) ←→ (750, y2')  [中段對中段]  
t=1   : (900, y3) ←→ (850, y3')  [尾部對尾部]

視差計算：
頭部視差 = 700 - 650 = 50 像素
中段視差 = 800 - 750 = 50 像素
尾部視差 = 900 - 850 = 50 像素
```

## 4. 為什麼這種方法更好？

### 優點：
1. **解剖學對應**：確保比較的是蝦子身體的同一部位
2. **尺度不變**：無論蝦子大小如何，都能找到正確的對應關係
3. **形狀適應**：適用於各種彎曲程度的蝦子
4. **視差一致性**：如果蝦子是剛體，所有部位的視差應該相近

### 限制：
1. **假設線性對應**：假設蝦子從頭到尾是線性對應的
2. **需要準確的遮罩**：依賴準確的物體分割結果
3. **忽略三維形狀**：假設蝦子在一個平面內

## 5. 實際應用效果

```python
# 假設執行結果：
左蝦子範圍: [680, 920] (長度240像素)
右蝦子範圍: [630, 870] (長度240像素)

採樣5個點的結果：
t=0.00: 左(680) ←→ 右(630), 視差=50
t=0.25: 左(740) ←→ 右(690), 視差=50  
t=0.50: 左(800) ←→ 右(750), 視差=50
t=0.75: 左(860) ←→ 右(810), 視差=50
t=1.00: 左(920) ←→ 右(870), 視差=50

結論：蝦子的視差一致為50像素，表示它在一個穩定的深度
```

## 6. 調試技巧

如果視差結果不合理，可以檢查：

1. **蝦子範圍是否正確**：
```python
print(f"左蝦子範圍: [{left_x_min}, {left_x_max}]")
print(f"右蝦子範圍: [{right_x_min}, {right_x_max}]") 
```

2. **採樣點是否在曲線上**：
```python
print(f"左採樣點: {list(zip(left_x, left_y))}")
print(f"右採樣點: {list(zip(right_x, right_y))}")
```

3. **視差是否合理**：
```python
disparities = left_x - right_x
print(f"視差分布: {disparities}")
print(f"平均視差: {np.mean(disparities):.2f}")
```
